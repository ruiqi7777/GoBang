# Gobang 实验报告

------



### **<u>一. 功能</u>**

1. 先手后手：开始默认玩家执黑棋，电脑执白棋，玩家是先手；可以点击界面中的“后手”选项，选择玩家是后手。
2. 悔棋：在下棋过程中，可以点击“悔棋”选项，界面会恢复成玩家下最后一步棋之前的界面。
3. 重新开始：在下棋的任意时刻，可以点击“重开”选项重新开始一盘棋局。
4. 退出：玩腻了，点击“退出”选项，直接退出程序。

### **<u>二. 实现过程</u>**

#### 备战

- Visual Studio 2022
- EasyX 图形库
- Typora
- Canva
- Visio
- 亿图图示
  - 后面这几个是绘图用的   ~~虽然鸡肋，但是画的很开心~~

#### 实战

除开main函数以外还有12个功能函数，可以分成以下几类：

##### 进行游戏初始化

| 初始化函数 |                    |
| :--------: | :----------------: |
| ChessBoard |      绘制棋盘      |
|    Init    | 初始化各落子点数据 |

- 绘制棋盘，显示悔棋、重开、后手和退出选项。
- 设置一个结构体存储各落子点的数据。
  - 棋盘的大小是15×15，但为了评估分数更加方便计算，用25×25的数组来进行储存，实际的棋盘边界是5到20

```
struct point {
	int state;                //位置的状态    玩家-1   空位置0   电脑1
	long double value;        //该点价值分
	long double n_value;      //下一步棋下这点时棋盘的总优势分
};
void Init(struct point p[25][25])
{
	int i, j;
	num = 0;
	for (i = 0; i < 25; i++)
	{
		for (j = 0; j < 25; j++)
		{
			p[i][j].state = 0;  
			p[i][j].value = 0;
			p[i][j].n_value = 0;
		}
	}
}
```

##### 处理玩家的操作

| 玩家操作函数 |                        |
| :----------: | :--------------------: |
|    Begin     | 开始游戏，获取鼠标信息 |
|  ClickBoard  |    检验是否有效点击    |
|    Regret    |          悔棋          |

- 首先开局获取鼠标信息，检验有效点击。
- 处理有效的鼠标信息。

在不考虑胜负的情况下，具体的思路如下：



<img src="C:\Users\86151\Desktop\思维导图.jpg" alt="思维导图" style="zoom:10%;" />



- 这一部分比较复杂的是悔棋	

定义宏变量记录上一步棋的位置。

```
int ii = 0, jj = 0;//黑棋坐标
int xx = 0, yy = 0;//白棋坐标
```

每下一步棋为宏变量重新赋值，记录最近一步黑白棋的坐标。当玩家选择悔棋时，首先将最新的黑白棋数据清除为空位，然后重新绘图。

```
void Regret(struct point p[25][25])
{
	ChessBoard();
	setcolor(BLACK);
	p[ii][jj].state = 0;                    
	p[xx][yy].state = 0;
	for (int i = MIN; i < MAX; i++) {       
		for (int j = MIN; j < MAX; j++) {
			if (p[i][j].state == -1) {
				setfillcolor(BLACK);
				fillcircle((i + 1 - MIN) * 50, (j + 1 - MIN) * 50, 20);
			}
			if (p[i][j].state == 1) {
				setfillcolor(WHITE);
				fillcircle((i + 1 - MIN) * 50, (j + 1 - MIN) * 50, 20);
			}
		}
	}
}
```

##### 判断游戏结束

| 结束函数 |          |
| :------: | :------: |
| CheckWin | 判断输赢 |
| GameOver | 结束界面 |

- 判断玩家胜利、玩家失败或者平局。
- 根据情况显示胜、败或者平局的界面。

##### 评分及AI落子

| AI落子函数 |            |
| :--------: | :--------: |
|  Assess_v  | 价值分评定 |
|  Assess_a  |  优势评估  |
| deduction  |  递归推演  |
|   AI_Go    |   AI执棋   |
|  Go_chess  |   AI落子   |

- 极大极小算法。此算法目的是寻找最优的方案使得自己能够利益最大化，即在完成利益值评价的候选方案方案中，对方总是选择候选方案中的最小值，而自己总是选择候选方案中的最大值。
- Alpha-Beta剪枝算法。由于博弈树呈指数增长，单独的极大极小算法会导致计算量过大，需要对算法进行优化，以加快搜索速度。还可以对没有价值的点进行剪枝，比如周围没有棋子的落子点，对落子点周围进行搜索，全为空时剪掉即可。
- 评分函数。用if语句对不同的情况进行赋分。对每个点进行赋分时，空点价值分为0，黑子和白子取相反数，每个点有8个方向的延伸价值，每个方向为5分，被对方或边界拦住价值分为0；两个相同棋子连在一起时分数乘一定的倍数，还有距离中心的优势分等等。
- AI寻找最佳落子坐标并落子。

某点进行价值判定时，空位置价值分为零，对于非空位置进行周围八个方向的搜索，某方向被棋子或者边界挡住分数为零，若己方棋子连续则分数翻倍，最终的价值分为各个方向分数的总和加上距离中心的优势分。

```
p[i][j].value = v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8 + 0.1 * (15 - abs(i - 12) - abs(j - 12)); 
```

先进行落子点的价值判定，棋盘的总优势分为所有落子点分数的集合。

```
double Assess_a(struct point p[25][25])
{
	int i, j;
	Assess_v(p);                      
	long double s_value = 0;
	for (i = MIN; i < MAX; i++)
	{
		for (j = MIN; j < MAX; j++)
		{
			s_value += p[i][j].value;
		}
	}
	return s_value;
}
```

进行递归推演和偏僻点剪枝，玩家回合找出下一步分数的最小值，AI回合就找出下一步分数的最大值，最后返回分数。

```
double deduction(struct point p[25][25], int sex, int depth, long double a, long double b)
{
	int m, n, i, j, t = 0, br = 0;
	long double va = 0;
	if (depth == 0 || CheckWin(p) != 0)  
	{
		return Assess_a(p);             
	}
	else if (sex % 2 == 1)              
	{
		for (m = MIN; m < MAX; m++)
		{
			if (br == 1)
			{   
				break;
			}
			for (n = MIN; n < MAX; n++)
			{
				if (p[m][n].state == 0)  
				{
					if (num < 80)
					{
						t = 0;
						for (i = -1; i < 2; i++) 
						{
							for (j = -1; j < 2; j++) 
							{
								if (p[i + m][j + n].state != 0) 
								{
									t++;   
								}
							}
						}
					}
					else 
					{
						t = 1;
					}
					if (t == 0)  
					{
						va = B;
					}
					else 
					{
						p[m][n].state = -1;    
						va = deduction(p, sex + 1, depth - 1, a, b);
						p[m][n].state = 0;   
					}
					if (va < b)   
					{
						b = va;
					}
					if (b < a)
					{
						break;    
						br = 1;
					}
				}
			}
		}
		return b; 
	}
	else if (sex % 2 == 0)     
	{
		for (m = MIN; m < MAX; m++)
		{
			if (br == 1)
			{  
				break;
			}
			for (n = MIN; n < MAX; n++)
			{
				if (p[m][n].state == 0)    
				{
					if (num < 80) 
					{
						t = 0;
						for (i = -1; i < 2; i++)
						{
							for (j = -1; j < 2; j++)
							{
								if (p[i + m][j + n].state != 0)
								{
									t++;    
								}
							}
						}
					}
					else
					{
						t = 1;
					}
					if (t == 0)  
					{
						va = A;
					}
					else
					{
						p[m][n].state = 1;    
						va = deduction(p, sex + 1, depth - 1, a, b);
						p[m][n].state = 0;     
					}
					if (va > a)   
					{
						a = va;
					}
					if (b < a)
					{
						break;    
						br = 1;
					}
				}
			}
		}
		return a;
	}
	return 0;
}
```

在控制AI落子的函数中寻找最佳落子位置，具体思路是在位置为空的情况下假设AI落子，利用递归推演获取价值分，找出分数最大时的坐标进行落子。细节是每假设一次计算出价值分后都要重新为该落子点赋状态值为0，以免影响后续假设评分。

### **<u>三. 效果</u>**

1. 开局界面：点击回车，开始游戏。

2. 功能界面：显示棋盘，右侧有功能选项——悔棋，重开，后手，退出。

3. 失败界面：显示失败，下方可以点击选项，选择重新开始游戏或者退出游戏。

4. 成功界面：显示成功，下方可以点击选项，选择重新开始游戏或者退出游戏。

5. 平局界面：显示平局，下方可以点击选项，选择重新开始游戏或者退出游戏。                                                                                                         

6. 五个界面的截图

   <img src="C:\Users\86151\Desktop\1.png" alt="1" style="zoom: 32%;" /><img src="C:\Users\86151\Desktop\2.png" alt="2" style="zoom: 32%;" /><img src="C:\Users\86151\Desktop\33.png" alt="33" style="zoom: 25%;" /><img src="C:\Users\86151\Desktop\4.png" alt="4" style="zoom: 25%;" /><img src="C:\Users\86151\Desktop\3.png" alt="3" style="zoom: 25%;" />

7. 速度：程序较小，运行速度很快。在不加以处理的情况下，玩家落子和AI落子之间几乎没有时间间隔。为使玩家不会感觉压力太大，在AI落子之前设置了一定的程序运行的停顿时间。

8. 棋力评价：（我个人就是停留在小学水平叭，小时候学会了就再也没碰过，所以和它下棋几乎没赢过，具体数据的话1/10）                         鉴于我个人五子棋水平没有参考价值，我下载了一个名为“途游五子棋”的软件，通过单机对弈模式进行评价我的五子棋AI的智能水平。“途游五子棋”的单机对弈模式分为初级、中级、高级和大师。在初级模式，五子棋AI战无不胜，在中级模式则和对方旗鼓相当，在高级模式胜利情况较少。综上，我的五子棋AI水平处于业余选手和职业选手之间，高于普通人，但低于大师水平。

### **<u>四. 总结心得</u>**

##### 待改进

1. 悔棋只能回退一步。我在程序中用数组存储上一步数据，或许可以改成压入和弹出栈的形式实现回滚多步。
2. 没有禁手和时间限制。~~对于像我这样太菜的人其实有没有关系不太大~~
3. 没有音效（落子、胜利、失败）。
4. 评分函数有待改进，单独的倍乘不太灵活，或许可以给各种形式单独赋分，所赋分值可以通过胜率调整。

##### 学到了

1. 极大极小算法
2. Alpha-Beta剪枝算法
3. 函数思想，有独立逻辑的部分可以写成函数，简洁清晰，避免无效重复。
4. 进行一个较为大型的项目时，应提前做好项目架构，将项目的各个功能模块计划好再开始详细编程，条理清晰。
5. 在整个程序中恒为常量的数值应该用define或者const，增加程序可读性并且利于未来可能的修改。
6. 注释真的很重要！尤其是长期项目，不然会回忆到头秃······
7. 设置全局变量可以在所有函数中通用，适用于存在于各个函数中的变量，例如落子点的坐标值。
   - 这一点我一开始没想到光想用return了，但是return只能传递一个值，落子坐标是x,y两个值，最后还是CSDN救了我。

### **<u>五.参考文献</u>**

关于极大极小算法和Alpha-Beta剪枝算法

- https://blog.csdn.net/IQIUM/article/details/110820903
- https://blog.csdn.net/housong_csdn/article/details/73920746